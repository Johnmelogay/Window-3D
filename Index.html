<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Janela 3D (iOS Fix)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; touch-action: none; }
        #container { position: relative; width: 100vw; height: 100vh; }
        canvas { display: block; width: 100%; height: 100%; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.95); z-index: 20; color: white; text-align: center;
            transition: opacity 0.5s;
        }
        
        .btn {
            padding: 20px 40px; font-size: 18px; font-weight: bold;
            background: #007AFF; color: white; border: none; border-radius: 12px;
            margin-top: 20px; cursor: pointer;
        }
        .btn-alt { background: #333; margin-top: 10px; font-size: 14px; }
        
        #debug-console {
            position: absolute; top: 10px; left: 10px; width: 90%;
            pointer-events: none; z-index: 5; color: #0f0; font-family: monospace; font-size: 12px;
            text-shadow: 1px 1px 0 #000;
            white-space: pre-wrap;
        }

        .hidden { opacity: 0; pointer-events: none; }
    </style>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
        }
    }
    </script>
</head>
<body>

    <div id="container">
        <div id="debug-console">Sistema pronto...</div>
        
        <div id="ui-layer">
            <div style="font-size: 50px; margin-bottom: 20px;">üì±</div>
            <h2>Modo iOS Seguro</h2>
            <p style="max-width: 80%; opacity: 0.8;">
                O iOS exige permiss√£o explicita.<br>
                Segure o celular na vertical.
            </p>
            <button id="btn-grant" class="btn">Permitir Sensores</button>
            <button id="btn-touch" class="btn btn-alt">Meus sensores n√£o funcionam (Usar Toque)</button>
            <div id="error-msg" style="color: #ff4444; margin-top: 15px; max-width: 80%; display: none;"></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- Configura√ß√£o ---
        let scene, camera, renderer;
        let targetX = 0, targetY = 0;
        let currentX = 0, currentY = 0;
        
        // Calibragem
        let refBeta = null, refGamma = null;
        
        // Input Fallback
        let isDragging = false;
        let lastTouchX = 0, lastTouchY = 0;
        let touchOffsetX = 0, touchOffsetY = 0;

        const debugEl = document.getElementById('debug-console');
        const ui = document.getElementById('ui-layer');
        const errorMsg = document.getElementById('error-msg');

        function log(msg) {
            debugEl.innerText = msg + "\n" + debugEl.innerText.split("\n").slice(0, 4).join("\n");
        }

        // --- 1. Three.js Setup (Otimizado) ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x101010);
            
            camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 100);
            camera.position.set(0, 0, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            // Cria√ß√£o da Sala
            const matWall = new THREE.MeshStandardMaterial({color: 0x808080, side: THREE.BackSide});
            const room = new THREE.Mesh(new THREE.BoxGeometry(20, 12, 20), matWall);
            scene.add(room);
            
            // Grid no fundo para refer√™ncia 3D
            const grid = new THREE.GridHelper(20, 10, 0x444444, 0x222222);
            grid.position.y = -6;
            scene.add(grid);

            // Objetos
            const geo = new THREE.IcosahedronGeometry(1);
            for(let i=0; i<10; i++) {
                const mesh = new THREE.Mesh(geo, new THREE.MeshNormalMaterial());
                mesh.position.set(
                    (Math.random()-0.5)*15,
                    (Math.random()-0.5)*8,
                    (Math.random()-0.5)*10 - 5
                );
                scene.add(mesh);
            }
            
            const light = new THREE.PointLight(0xffffff, 100, 50);
            light.position.set(0, 5, 5);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));

            animate();
        }

        // --- 2. L√≥gica de Sensores (iOS Hardened) ---
        
        function handleOrientation(e) {
            const beta = e.beta;   // X axis (-180, 180)
            const gamma = e.gamma; // Y axis (-90, 90)
            
            if (beta === null || gamma === null) return;

            // Calibrar no primeiro frame v√°lido
            if (refBeta === null) {
                refBeta = beta;
                refGamma = gamma;
                log("Sensores Calibrados!");
                return;
            }

            // Calcular movimento relativo
            // iOS √†s vezes inverte eixos dependendo da orienta√ß√£o da tela, assumimos Portrait
            targetX = (gamma - refGamma) * 0.3 + touchOffsetX;
            targetY = (beta - refBeta) * 0.3 + touchOffsetY;
            
            log(`B:${Math.floor(beta)} G:${Math.floor(gamma)}`);
        }

        async function requestIOSPermission() {
            if (typeof DeviceOrientationEvent !== 'undefined' && 
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                
                try {
                    log("Solicitando permiss√£o iOS...");
                    const permission = await DeviceOrientationEvent.requestPermission();
                    
                    if (permission === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation);
                        hideUI();
                        log("Permiss√£o iOS CONCEDIDA");
                    } else {
                        throw new Error("Permiss√£o negada pelo usu√°rio: " + permission);
                    }
                } catch (e) {
                    showError("Erro iOS: " + e.message);
                    log("Falha iOS: " + e.message);
                    
                    // Fallback autom√°tico para modo toque se falhar
                    setTimeout(() => {
                         log("Ativando modo toque...");
                         enableTouchMode();
                         hideUI();
                    }, 2000);
                }
            } else {
                // Android ou PC (n√£o precisa requestPermission)
                window.addEventListener('deviceorientation', handleOrientation);
                hideUI();
                log("Sensores iniciados (Modo Padr√£o)");
            }
        }

        // --- 3. Fallback Touch ---
        function enableTouchMode() {
            document.addEventListener('touchstart', e => {
                isDragging = true;
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            }, {passive: false});
            
            document.addEventListener('touchmove', e => {
                if (!isDragging) return;
                e.preventDefault(); // Previne scroll
                const dx = e.touches[0].clientX - lastTouchX;
                const dy = e.touches[0].clientY - lastTouchY;
                
                touchOffsetX -= dx * 0.05; // Invertido para sensa√ß√£o de "arrastar a janela"
                touchOffsetY += dy * 0.05;
                
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
                
                // Se n√£o houver sensor, atualiza direto
                if (refBeta === null) {
                    targetX = touchOffsetX;
                    targetY = touchOffsetY;
                }
            }, {passive: false});
            
            document.addEventListener('touchend', () => isDragging = false);
            
            // Mouse (Desktop)
            document.addEventListener('mousedown', e => {
                isDragging = true;
                lastTouchX = e.clientX;
                lastTouchY = e.clientY;
            });
            document.addEventListener('mousemove', e => {
                if(!isDragging) return;
                const dx = e.clientX - lastTouchX;
                const dy = e.clientY - lastTouchY;
                touchOffsetX -= dx * 0.05;
                touchOffsetY += dy * 0.05;
                lastTouchX = e.clientX;
                lastTouchY = e.clientY;
                if(refBeta === null) { targetX = touchOffsetX; targetY = touchOffsetY; }
            });
            document.addEventListener('mouseup', () => isDragging = false);
        }

        // --- 4. Helpers UI ---
        function hideUI() {
            ui.classList.add('hidden');
        }

        function showError(msg) {
            errorMsg.style.display = 'block';
            errorMsg.innerText = msg + "\n\nTente abrir no Safari fora do chat.";
        }

        // --- 5. Event Listeners ---
        document.getElementById('btn-grant').addEventListener('click', requestIOSPermission);
        
        document.getElementById('btn-touch').addEventListener('click', () => {
            enableTouchMode();
            hideUI();
            log("Modo Toque Manual Ativado");
        });

        // Loop de Anima√ß√£o
        function animate() {
            requestAnimationFrame(animate);

            // Lerp para suavidade
            currentX += (targetX - currentX) * 0.1;
            currentY += (targetY - currentY) * 0.1;

            // Limites
            currentX = Math.max(-20, Math.min(20, currentX));
            currentY = Math.max(-15, Math.min(15, currentY));

            camera.position.x = currentX;
            camera.position.y = currentY;
            camera.lookAt(0, 0, -10); // Look at fixed point inside room

            renderer.render(scene, camera);
        }

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Verifica HTTPS
        if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
            showError("Aten√ß√£o: Sensores exigem HTTPS.");
        }

        init();
        // Ativa toque sempre como backup em background
        enableTouchMode();

    </script>
</body>
</html>


